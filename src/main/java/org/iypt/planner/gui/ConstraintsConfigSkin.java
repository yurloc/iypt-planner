package org.iypt.planner.gui;

import java.awt.Color;
import org.apache.pivot.collections.HashMap;
import org.apache.pivot.collections.Map;
import org.apache.pivot.wtk.Component;
import org.apache.pivot.wtk.Dimensions;
import org.apache.pivot.wtk.Label;
import org.apache.pivot.wtk.TablePane;
import org.apache.pivot.wtk.TextInput;
import org.apache.pivot.wtk.TextInputContentListener;
import org.apache.pivot.wtk.skin.ContainerSkin;
import org.drools.planner.core.score.constraint.ConstraintType;
import org.iypt.planner.gui.ConstraintsConfig.Constraint;

/**
 *
 * @author jlocker
 */
public class ConstraintsConfigSkin extends ContainerSkin implements ConstraintsConfigListener {

    private TablePane content;
    private static final Map<String, Object> borderStyles = new HashMap<>();
    private static final Map<String, Object> hardConstraintStyles = new HashMap<>();
    private static final String EXPLANATION = "Hard constraints are weighted equally. There's no point in modifying the weights.";

    static {
        borderStyles.put("padding", 10);
        borderStyles.put("thickness", 0);
        hardConstraintStyles.put("color", Color.RED.darker());
    }

    /* 1. call super.install()
     * 2. cast Component to the class this Skin is designed for
     * 3. add this to the component's listeners
     * 4. add the content created by this skin to the component (Container)
     * 5. call a change event
     */
    @Override
    public void install(Component component) {
        super.install(component);
        ConstraintsConfig config = (ConstraintsConfig) component;
        config.getConstraintsConfigListeners().add(this);

        content = new TablePane();
        content.getColumns().add(new TablePane.Column());
        content.getColumns().add(new TablePane.Column());
        config.add(content);

        constraintsChanged(config);
    }

    // following four methods reflect the prefered size of the content generated by this skin
    @Override
    public int getPreferredWidth(int height) {
        return content.getPreferredWidth(height);
    }

    @Override
    public int getPreferredHeight(int width) {
        return content.getPreferredHeight(width);
    }

    @Override
    public Dimensions getPreferredSize() {
        return content.getPreferredSize();
    }

    @Override
    public void layout() {
        content.setLocation(0, 0);
        content.setSize(getWidth(), getHeight());
    }

    // listen for changes of the constraint list
    @Override
    public void constraintsChanged(ConstraintsConfig config) {
        content.getRows().remove(0, content.getRows().getLength());
        for (final Constraint constraint : config.getConstraints()) {
            TablePane.Row row = new TablePane.Row();
            content.getRows().add(row);
            Label label = new Label(constraint.getName());
            row.add(label);

            if (constraint.getType() == ConstraintType.NEGATIVE_HARD) {
                label.setStyles(hardConstraintStyles);
                Label wLabel = new Label("--");
                row.add(wLabel);
                label.setTooltipText(EXPLANATION);
                wLabel.setTooltipText(EXPLANATION);
            } else {
                TextInput textInput = new TextInput();
                row.add(textInput);
                textInput.setText(Integer.toString(constraint.getWeight()));
                textInput.getTextInputContentListeners().add(new TextInputContentListener.Adapter() {
                    @Override
                    public void textChanged(TextInput textInput) {
                        String text = textInput.getText();
                        if (!text.isEmpty()) {
                            constraint.setWeight(Integer.parseInt(text));
                        }
                    }
                });
            }

        }
    }
}
