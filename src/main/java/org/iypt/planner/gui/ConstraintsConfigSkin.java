package org.iypt.planner.gui;

import java.awt.Color;
import org.apache.pivot.collections.HashMap;
import org.apache.pivot.collections.Map;
import org.apache.pivot.wtk.Component;
import org.apache.pivot.wtk.ComponentKeyListener;
import org.apache.pivot.wtk.ComponentStateListener;
import org.apache.pivot.wtk.Dimensions;
import org.apache.pivot.wtk.FocusTraversalDirection;
import org.apache.pivot.wtk.Keyboard;
import org.apache.pivot.wtk.Keyboard.KeyLocation;
import org.apache.pivot.wtk.Label;
import org.apache.pivot.wtk.TablePane;
import org.apache.pivot.wtk.TextInput;
import org.apache.pivot.wtk.TextInputContentListener;
import org.apache.pivot.wtk.skin.ContainerSkin;
import org.apache.pivot.wtk.validation.Validator;
import org.drools.planner.core.score.constraint.ConstraintType;
import org.iypt.planner.gui.ConstraintsConfig.Constraint;

/**
 *
 * @author jlocker
 */
public class ConstraintsConfigSkin extends ContainerSkin implements ConstraintsConfigListener {

    private TablePane content;
    private static final Map<String, Object> borderStyles = new HashMap<>();
    private static final Map<String, Object> hardConstraintStyles = new HashMap<>();
    private static final String EXPLANATION = "Hard constraints are weighted equally. There's no point in modifying the weights.";

    static {
        borderStyles.put("padding", 10);
        borderStyles.put("thickness", 0);
        hardConstraintStyles.put("color", Color.RED.darker());
    }

    /* 1. call super.install()
     * 2. cast Component to the class this Skin is designed for
     * 3. add this to the component's listeners
     * 4. add the content created by this skin to the component (Container)
     * 5. call a change event
     */
    @Override
    public void install(Component component) {
        super.install(component);
        ConstraintsConfig config = (ConstraintsConfig) component;
        config.getConstraintsConfigListeners().add(this);

        content = new TablePane();
        content.getColumns().add(new TablePane.Column());
        content.getColumns().add(new TablePane.Column());
        config.add(content);

        constraintsChanged(config);
    }

    // following four methods reflect the prefered size of the content generated by this skin
    @Override
    public int getPreferredWidth(int height) {
        return content.getPreferredWidth(height);
    }

    @Override
    public int getPreferredHeight(int width) {
        return content.getPreferredHeight(width);
    }

    @Override
    public Dimensions getPreferredSize() {
        return content.getPreferredSize();
    }

    @Override
    public void layout() {
        content.setLocation(0, 0);
        content.setSize(getWidth(), getHeight());
    }

    // listen for changes of the constraint list
    @Override
    public void constraintsChanged(ConstraintsConfig config) {
        content.getRows().remove(0, content.getRows().getLength());
        for (final Constraint constraint : config.getConstraints()) {
            TablePane.Row row = new TablePane.Row();
            content.getRows().add(row);
            Label label = new Label(constraint.getName());
            row.add(label);

            if (constraint.getType() == ConstraintType.NEGATIVE_HARD) {
                label.setStyles(hardConstraintStyles);
                Label wLabel = new Label("--");
                row.add(wLabel);
                label.setTooltipText(EXPLANATION);
                wLabel.setTooltipText(EXPLANATION);
            } else {
                TextInput textInput = new TextInput();
                textInput.getComponentKeyListeners().add(new ComponentKeyListener.Adapter() {
                    @Override
                    public boolean keyPressed(Component component, int keyCode, KeyLocation keyLocation) {
                        boolean consumed = super.keyPressed(component, keyCode, keyLocation);

                        FocusTraversalDirection dir;
                        switch (keyCode) {
                            case Keyboard.KeyCode.DOWN:
                                dir = FocusTraversalDirection.FORWARD;
                                break;
                            case Keyboard.KeyCode.UP:
                                dir = FocusTraversalDirection.BACKWARD;
                                break;
                            default:
                                // do as usual
                                return consumed;
                        }
                        Component next = component;
                        while ((next = content.getFocusTraversalPolicy().getNextComponent(content, next, dir)) != null
                                && !next.isFocusable()) {
                            // skip unfocusable components
                        }
                        if (next != null) {
                            next.requestFocus();
                            consumed = true;
                        }
                        return consumed;
                    }
                });
                textInput.setValidator(new Validator() {
                    @Override
                    public boolean isValid(String text) {
                        return text.matches("\\d+");
                    }
                });
                ResettingInputListener resettingInputListener = new ResettingInputListener() {
                    @Override
                    public void processValidText(String text) {
                        constraint.setWeight(Integer.parseInt(text));
                    }
                };
                textInput.getComponentStateListeners().add(resettingInputListener);
                textInput.getTextInputContentListeners().add(resettingInputListener);
                textInput.setText(Integer.toString(constraint.getWeight()));
                row.add(textInput);
            }
        }
    }

    private abstract class ResettingInputListener extends TextInputContentListener.Adapter implements ComponentStateListener {

        private String lastValidText;

        @Override
        public void textChanged(TextInput textInput) {
            if (textInput.isTextValid()) {
                lastValidText = textInput.getText();
                processValidText(lastValidText);
            }
        }

        @Override
        public void enabledChanged(Component component) {
            // not interested
        }

        @Override
        public void focusedChanged(Component component, Component obverseComponent) {
            TextInput textInput = (TextInput) component;
            if (!textInput.isFocused() && !textInput.isTextValid()) {
                // restore the last valid text
                textInput.setText(lastValidText);
            }
        }

        public abstract void processValidText(String text);
    }
}
